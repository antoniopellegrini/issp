# Help Mallory eavesdrop on the communication between Alice and Bob by correctly guessing
# the ephemeral keys used for One-Time Pad (OTP) encryption.
#
# Mallory knows that the ephemeral keys are 32 bytes long, and that they are generated
# using a Linear Congruential Generator (LCG) with unknown parameters.
#
# Mallory has access to a number of consecutive values generated by the LCG,
# and knows that the modulus m is either a power of 2 or a Mersenne prime
# (i.e. a prime of the form 2^p - 1).
#
# Hint: You will need to solve a system of linear integer equations modulo m.
#       In this very simple case you can solve it with regular arithmetic,
#       making sure to use modular inverses (pow(x, -1, modulus)) instead of division.

import time

from issp import LCG, OTP, Actor, Channel, EncryptionLayer, log


def lcg(a: int, c: int, m: int, state: int) -> int:
    return (a * state + c) % m


def compute_ac(m: int, x0: int, x1: int, x2: int) -> tuple[int, int]:
    # Eq 1:         x1 = a * x0 + c (mod m)
    # Eq 2:         x2 = a * x1 + c (mod m)
    # Eq2 - Eq1:    x2 - x1 = a * (x1 - x0) (mod m)
    # We now get:   a = (x2 - x1) * (x1 - x0)^(-1) (mod m)
    # And:          c = x1 - a * x0 (mod m)
    a = ((x2 - x1) * pow((x1 - x0), -1, m)) % m
    c = (x1 - a * x0) % m
    return a, c


def check_m(m: int, values: list[int]) -> bool:
    try:
        a, c = compute_ac(m, values[0], values[1], values[2])
    except ValueError:
        return False
    return all(lcg(a, c, m, values[i]) == values[i + 1] for i in range(len(values) - 1))


def main() -> None:
    alice = Actor("Alice")
    bob = Actor("Bob")
    mallory = Actor("Mallory")

    channel = Channel()
    alice_bob_rng = LCG()

    # Values known to Mallory.
    values = [alice_bob_rng.next_value() for _ in range(6)]

    # Find the modulus m.
    for e in range(64):
        m = 2**e
        if check_m(m, values):
            break
        m -= 1
        if check_m(m, values):
            break

    # Compute a and c.
    a, c = compute_ac(m, values[0], values[1], values[2])
    log.info("Mallory found the LCG parameters: a=%d, c=%d, m=%d", a, c, m)

    # Mallory can now generate the same sequence of values as Alice and Bob.
    mallory_rng = LCG(a=a, c=c, m=m)
    mallory_rng.set_seed(values[-1])

    alice_bob_cipher = OTP()
    alice_bob_layer = EncryptionLayer(channel, alice_bob_cipher)

    mallory_cipher = OTP()
    mallory_layer = EncryptionLayer(channel, mallory_cipher)

    for i in range(10):
        time.sleep(1.0)
        alice_bob_cipher.key = alice_bob_rng.generate(32)
        message = f"{i}. Hello, Bob! - Alice"
        alice.send(alice_bob_layer, message.encode())

        mallory_cipher.key = mallory_rng.generate(32)
        mallory.receive(mallory_layer)

        bob.receive(alice_bob_layer)


if __name__ == "__main__":
    main()
